
% type-safety-proof.tex - Proof of progress and proof of preservation for my JavaScript subset

\documentclass[a4paper]{article}

\usepackage{times}
\usepackage{amsmath,amssymb}
\usepackage{fixltx2e}
\usepackage{amsthm}
\usepackage{thmtools}
\newtheoremstyle{dotless}{\topsep}{\topsep}{\itshape}{}{\bfseries}{}{5pt plus 1pt minus 1pt}{}
\theoremstyle{dotless}
\newtheorem{theorem}{Theorem}[section]
\usepackage{etoolbox}
\makeatletter
\patchcmd{\@thm}{\trivlist}{\list{}{ \leftmargin=1.5em}}{}{}
\patchcmd{\@endtheorem}{\endtrivlist}{\endlist}{}{}
\makeatother

\declaretheoremstyle[
  spaceabove=6pt, spacebelow=6pt,
  headfont=\normalfont\bfseries, numbered=no,
  notefont=\scshape, headpunct={\\}, notebraces={}{},
  bodyfont=\normalfont,
  postheadspace=1em
]{casestyle}
\declaretheoremstyle[
  spaceabove=6pt, spacebelow=3pt,
  headfont=\normalfont\bfseries,
  notefont=\scshape, headpunct={}, numbered=no,
  bodyfont=\normalfont,
  postheadspace=1em
]{subcasestyle}
\declaretheorem[style=casestyle]{case}
\declaretheorem[style=subcasestyle, name=case]{subcase}

\begin{document}

\title{Proof of Type Safety}
\author{Christopher Little}
\maketitle

\section{Progress}
\newcommand{\typable}[2][ ]{\Gamma{}\vdash#2\, |C#1\:\Gamma#1'}
\newcommand{\typed}[2]{\Gamma{}\vdash#1: #2\,|_C\:\Gamma'}
\newcommand{\transition}[6]{\langle{}#1,#2,#3\rangle{}\rightarrow{}\langle{}#4,#5,#6\rangle}
\newcommand{\indHyp}{\Phi(\Gamma, m, C, \Gamma')}
\newcommand{\indHypTwo}{\Psi(\Gamma, e, T, C, \Gamma')}
\newcommand{\var}{\textbf{var}}
\newcommand{\sub}[1]{\textsubscript{#1}}

\begin{theorem}[Progress for expressions]\label{expProgress}

  If $\typed{e}{T}$ and $dom(\Gamma) \subseteq dom(s)$ then either e is a
  value or there exist $e'$, $s'$ such that $\transition{e}{s}{\theta}{e'}{s'}{\theta'}$

\end{theorem}

\begin{proof}\label{expProgressProof}
  Take $$ \indHypTwo \stackrel{\text{def}}{=} \\
  \forall s.  (dom(\Gamma) \subseteq\ dom(s)) \implies val(e) \vee
  \exists e', s'. \transition{e}{s}{\theta}{e'}{s'}{\theta'} $$

  We show that for all $\Gamma$, $e$, $T$, $C$, $\Gamma'$, if
  $\typed{e}{T}$ then $\indHypTwo$, by rule induction on the definition of
  the type judgements. Since $\Psi$ is of the form $\forall s.dom(\Gamma) \subseteq\ dom(s)\implies\dots$, in all cases consider an arbitrary s
  and assume $dom(\Gamma) \subseteq\ dom(s)$.

  \begin{case}[V\_Num, V\_Bool, V\_String, V\_Undefined, V\_Null, V\_Closure]\label{values} 

	For each of these rules, we immediately have that $e$ is a value, which
	gives us $\indHypTwo{}$ as desired.

  \end{case}

  \begin{case}[V\_Obj]\label{v_obj}

	$e$ is of the form $\mathtt{\{l_1: e_1,\ \dots,\ l_k: e_k\}}$, and we have $\typed{e_i}{T}$ for $1 \leq i \leq k$.
	We can use the induction hypothesis to determine that each $e_i$ must
	either be a value or reduces futher.
	\begin{subcase}
	  all $e_i$ are values. $e$ is itself a value, so $\indHypTwo$ is
	  satisfied.
  	\end{subcase}
  	\begin{subcase}
  	  some $e_j$ is further reducible, where $j$ is the smallest index such
  	  that $e_j$ is not a value. $e$ itself must be further reducible by
  	  rule \textsc{Obj}, and again $\indHypTwo$ is satisfied.
	\end{subcase}
  \end{case}

  \begin{case}[V\_Arr]\label{v_arr}

	$e$ is of the form $\mathtt{[e_1,\ \dots,\ e_i]}$, and we have $\typed{e_i}{T}$ for $1 \leq i \leq k$.
	The proof is similar to the case for \textsc{V\_Obj}, using rule
	\textsc{Arr} in the case when some $e_j$ can reduce further.

  \end{case}

  \begin{case}[Fun1]\label{fun1}
	\texttt{TODO}
  \end{case}

  \begin{case}[Fun2]\label{fun2}
	\texttt{TODO}
  \end{case}

  \begin{case}[Fun3]\label{fun3}
	\texttt{TODO}
  \end{case}

  \begin{case}[Fun4]\label{fun4}
	\texttt{TODO}
  \end{case}

  \begin{case}[IDType]\label{idtype}
	\texttt{TODO}
  \end{case}

  \begin{case}[PropType]\label{proptype}

	$e$ is of the form $\mathtt{e_1.l}$. For this to be a valid type
	judgement, $\typed{e_1}{T_1}$ must hold. From the induction
	hypothesis, $e_1$ must be either a value or further reducible.
	\begin{subcase}
	  $e_1$ is further reducible. The precondition for rule \textsc{Prop1} is
	  satisfied, and $e$ is further reducible under this rule.
  	\end{subcase}
  	\begin{subcase}
  	  $e_1$ is a value. It must be an object with property \texttt{\{l: v\}}
	  in order to satisfy the constraint $\{\{l:T\}\succeq T_1\}$. In this case, the rule
	  \textsc{Prop2} is applicable, and $e$ is further reducible.
  	\end{subcase}
  \end{case}

  \begin{case}[ArrayType]\label{arraytype}

	$e$ is of the form $\mathtt{e_1[e_2]}$. For this to be a valid
	judgement, $\typed{e_1}{T_1}$ and $\typed{e_2}{T_2}$ must hold. From
	the induction hypothesis, then, we have that $e_1$ and $e_2$ are both
	either values or reduce further.

	\begin{subcase}
	  $e_1$ reduces further. Then the preconditions for rule
	  \textsc{ArrGet1} are satisfied, and $e$ itself reduces further under
	  this rule.
	\end{subcase}

	\begin{subcase}
	  $e_2$ reduces further. Then the preconditions for rule
	  \textsc{ArrGet2} are satisfied, and $e$ itself reduces further under
	  this rule.
  	\end{subcase}

  	\begin{subcase}
	  both $e_1$ and $e_2$ are values. Then $e_1$ must be of the form 
	  $\mathtt{[v_1,\ \dots,\ v_k]}$, to satisfy the constraint $\{[T] \succeq T_1\}$,
	  and $e_2$ must be a number to satisfy the constraint $\{T_2=number\}$.
	  $e$ is then of the form $\mathtt{[v_1,\ \dots,\ v_k][n]}$, and we 
	  can use \textsc{ArrGet3} to reduce $e$ further.
  	\end{subcase}

  \end{case}

  \begin{case}[CallType]\label{calltype}
	\texttt{TODO}
  \end{case}

  \begin{case}[PropCallType]\label{propcalltype}
	\texttt{TODO}
  \end{case}

  \begin{case}[AssignType]\label{assigntype}
	\texttt{TODO}
  \end{case}

  \begin{case}[AssignTypeUndef]\label{assigntypeundef}
	\texttt{TODO}
  \end{case}

  \begin{case}[PropAssignType]\label{propassigntype}
	\texttt{TODO}
  \end{case}

  \begin{case}[ArrayAssignType]\label{arrayassigntype}
	\texttt{TODO}
  \end{case}

  \begin{case}[NumAssignType]\label{numassigntype}
	\texttt{TODO}
  \end{case}

  \begin{case}[PropNumAssignType]\label{propnumassigntype}
	\texttt{TODO}
  \end{case}

  \begin{case}[ArrayNumAssignType]\label{arraynumassigntype}
	\texttt{TODO}
  \end{case}

  \begin{case}[NumOpType, BoolOpType, CmpOpType, NumCmpOpType]\label{binoptype}
  	$e$ is of the form $\mathtt{e_1\ op\ e_2}$. For this to be a valid
  	judgement, $\typed{e_1}{T_1}$ and $\typed{e_1}{T_1}$ must both hold. From
  	the induction hypothesis, both $e_1$ and $e_2$ must either reduce further
  	or already be values.

  	\begin{subcase}
  	  $e_1$ is further reducible. The precondition for rule \textsc{BinOp1} is
  	  satisfied, and $e$ is further reducible under this rule. Hence
  	  $\indHypTwo$ holds.
 	\end{subcase}

  	\begin{subcase}
  	  $e_2$ is further reducible. The precondition for rule \textsc{BinOp2} is
  	  satisfied, and $e$ is further reducible under this rule. Hence
  	  $\indHypTwo$ holds.
 	\end{subcase}

	\begin{subcase}
	  $e_1$ and $e_2$ are both values. 
		% To satisfy the constraints $\{T_1=number\}$
		% and $\{T_2=number\}$, $e_1$ and $e_2$ must both be numbers.
	  The precondition for rule \textsc{BinOp3} is thus satisfied, and $e$ is
	  further reducible under this rule.
	\end{subcase}
  \end{case}

  \begin{case}[NegType]\label{negtype}
	$e$ is of the form $\mathtt{!e_1}$. For this to be a valid judgement,
	$\typed{e_1}{T_1}$ must hold, and from the induction hypothesis $e_1$ must
	either reduce further or already be a value.

	\begin{subcase}
	  $e_1$ is further reducible. Then the precondition for rule \textsc{UnOp1}
	  is satisfied, and $e$ itself reduces further.
	\end{subcase}

	\begin{subcase}
	  $e_1$ is a value. In order for the constraint $\{T_1=boolean\}$ to be
	  satisfied, $e_1$ must be a boolean value. Hence 
	  rule \textsc{BoolNeg} is applicable, and $e$ itself is further reducible.
	\end{subcase}
  \end{case}

  \begin{case}[PreNumType]\label{prenumtype}
	$e$ is of the form $\mathtt{preNum\ e_1}$. For this to be a valid judgement,
	$\typed{e_1}{T_1}$ must hold, and from the induction hypothesis $e_1$ must
	either reduce further or already be a value.
	\begin{subcase} $preOp=-$. 
	  \begin{subcase}
	  	$e_1$ is further reducible. Then the precondition for rule \textsc{UnOp1}
	  	is satisfied, and $e$ itself reduces further.
	  \end{subcase}
	  \begin{subcase}
	  	$e_1$ is a value. In order to satisfy the constraint $\{T_1=number\}$,
	  	$e_1$ must be a number. Rule \textsc{NumNeg} is immediately applicable
	  	and $e$ itself reduces further.
	  \end{subcase}
	\end{subcase}
	\begin{subcase} $preOp\neq-$. 
	  \texttt{TODO}
	\end{subcase}
  \end{case}

  \begin{case}[PostOpType]\label{postoptype}
  	Similar to the subcase of \textsc{PreNumType} where $preOp\neq-$.
  \end{case}

\end{proof}



\section*{Preservation}

We want to show that typability is preserved by all possible transitions
in the language. We can show this by structural induction over the
derivation of the typability judgement for some statement $m$, using the
following induction hypothesis:


\end{document}
