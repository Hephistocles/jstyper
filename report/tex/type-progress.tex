
% type-safety-proof.tex - Proof of progress and proof of preservation for my JavaScript subset

\documentclass[a4paper]{article}

\usepackage{times}
\usepackage{amsmath,amssymb}
\usepackage{fixltx2e}
\usepackage{amsthm}
\usepackage{thmtools}
\newtheoremstyle{dotless}{\topsep}{\topsep}{\itshape}{}{\bfseries}{}{5pt plus 1pt minus 1pt}{}
\theoremstyle{dotless}
\newtheorem{theorem}{Theorem}[section]
\usepackage{etoolbox}
\makeatletter
\patchcmd{\@thm}{\trivlist}{\list{}{ \leftmargin=1.5em}}{}{}
\patchcmd{\@endtheorem}{\endtrivlist}{\endlist}{}{}
\makeatother

\declaretheoremstyle[
  spaceabove=6pt, spacebelow=6pt,
  headfont=\normalfont\bfseries, numbered=no,
  notefont=\scshape, headpunct={\\}, notebraces={}{},
  bodyfont=\normalfont,
  postheadspace=1em
]{casestyle}
\declaretheoremstyle[
  spaceabove=6pt, spacebelow=3pt,
  headfont=\normalfont\bfseries,
  notefont=\scshape,
  bodyfont=\normalfont,
  postheadspace=1em
]{subcasestyle}
\declaretheorem[style=subcasestyle, name=case]{subcase}
\declaretheorem[style=casestyle]{case}

\begin{document}

\title{Proof of Type Safety}
\author{Christopher Little}
\maketitle

\section{Progress}
\newcommand{\typable}[2][ ]{\Gamma{}\vdash#2\, |C#1\:\Gamma#1'}
\newcommand{\typed}[2]{\Gamma{}\vdash#1: #2\,|_C\:\Gamma'}
\newcommand{\transition}[6]{\langle{}#1,#2,#3\rangle{}\rightarrow{}\langle{}#4,#5,#6\rangle}
\newcommand{\indHyp}{\Phi(\Gamma, m, C, \Gamma')}
\newcommand{\indHypTwo}{\Psi(\Gamma, e, T, C, \Gamma')}
\newcommand{\var}{\textbf{var}}
\newcommand{\sub}[1]{\textsubscript{#1}}

\begin{theorem}[Progress for expressions]\label{expProgress}

  If $\typed{e}{T}$ and $dom(\Gamma) \subseteq dom(s)$ then either e is a
  value or there exist $e'$, $s'$ such that $\transition{e}{s}{\theta}{e'}{s'}{\theta'}$

\end{theorem}

\begin{proof}\label{expProgressProof}
  Take $$ \indHypTwo \stackrel{\text{def}}{=} \\
  \forall s.  (dom(\Gamma) \subseteq\ dom(s)) \implies val(e) \vee
  \exists e', s'. \transition{e}{s}{\theta}{e'}{s'}{\theta'} $$

  We show that for all $\Gamma$, $e$, $T$, $C$, $\Gamma'$, if
  $\typed{e}{T}$ then $\indHypTwo$, by rule induction on the definition of
  the type judgements. Since $\Psi$ is of the form $\forall s.dom(\Gamma) \subseteq\ dom(s)\implies\dots$, in all cases consider an arbitrary s
  and assume $dom(\Gamma) \subseteq\ dom(s)$.

  \begin{case}[V\_Num, V\_Bool, V\_String, V\_Undefined, V\_Null, V\_Closure]\label{values} 

	For each of these rules, we immediately have that $e$ is a value, which
	gives us $\indHypTwo{}$ as desired.

  \end{case}

  \begin{case}[V\_Obj]\label{v_obj}

	$e$ is of the form $\mathtt{\{l_1: e_1,\ \dots,\ l_k: e_k\}}$, and we have $\typed{e_i}{T}$ for $1 \leq i \leq k$.
	We can use the induction hypothesis to determine that each $e_i$ must
	either be a value or reduces futher. If all $e_i$ are values, then $e$
	itself is a value. If not, then $e_j$ must be further reducible, where
	$j$ is the smalest index such that $e_j$ is not a value. Then $e$
	itself must be further reducible by rule \textsc{Obj}. In either case,
	$\indHypTwo$ is satisfied.

  \end{case}

  \begin{case}[V\_Arr]\label{v_arr}

	$e$ is of the form $\mathtt{[e_1,\ \dots,\ e_i]}$, and we have $\typed{e_i}{T}$ for $1 \leq i \leq k$.
	The proof is similar to the case for \textsc{V\_Obj}, using rule
	\textsc{Arr} in the case when some $e_j$ can reduce further.

  \end{case}

  \begin{case}[Fun1]\label{fun1}
	\texttt{TODO}
  \end{case}

  \begin{case}[Fun2]\label{fun2}
	\texttt{TODO}
  \end{case}

  \begin{case}[Fun3]\label{fun3}
	\texttt{TODO}
  \end{case}

  \begin{case}[Fun4]\label{fun4}
	\texttt{TODO}
  \end{case}

  \begin{case}[IDType]\label{idtype}
	\texttt{TODO}
  \end{case}

  \begin{case}[PropType]\label{proptype}

	$e$ is of the form $\mathtt{e_1.l}$. For this to be a valid type
	judgement, $\typed{e_1}{T_1}$ must hold. From the induction
	hypothesis, $e_1$ must be either a value or further reducible.

	If it is further reducible, then the precondition for \textsc{Prop1} is
	satisfied, and $e$ is further reducible under this rule.

	If it is a value, it must be an object with property \texttt{\{l: v\}}
	in order to satisfy $\{\{l:T\}\succeq T_1\}$. In this case, the rule
	\textsc{Prop2} is applicable, and $e$ is further reducible.

  \end{case}

  \begin{case}[ArrayType]\label{arraytype}

	$e$ is of the form $\mathtt{e_1[e_2]}$. For this to be a valid
	judgement, $\typed{e_1}{T_1}$ and $\typed{e_2}{T_2}$ must hold. From
	the induction hypothesis, then, we have that $e_1$ and $e_2$ are both
	either values or reduce further.

	\begin{subcase}
	  If $e_1$ reduces further, then the preconditions for rule
	  \textsc{ArrGet1} are satisfied, and $e$ itself reduces further under
	  this rule.
	\end{subcase}

	If $e_2$ reduces further, then the preconditions for rule
	\textsc{ArrGet2} are satisfied, and $e$ itself reduces further under
	this rule.

	If both $e_1$ and $e_2$ are values, then $e_1$ must be of the form 
	$\mathtt{[v_1,\ \dots,\ v_k]}$, to satisfy the constraint $\{[T] \succeq T_1\}$,
	and $e_2$ must be a number to satisfy the constraint $\{T_2=number\}$.
	$e$ is then of the form $\mathtt{[v_1,\ \dots,\ v_k][n]}$, and we 
	can use \textsc{ArrGet3} to reduce $e$ further.

  \end{case}

  \begin{case}[CallType]\label{calltype}
	\texttt{TODO}
  \end{case}

  \begin{case}[PropCallType]\label{propcalltype}
	\texttt{TODO}
  \end{case}

  \begin{case}[AssignType]\label{assigntype}
	\texttt{TODO}
  \end{case}

  \begin{case}[AssignTypeUndef]\label{assigntypeundef}
	\texttt{TODO}
  \end{case}

  \begin{case}[PropAssignType]\label{propassigntype}
	\texttt{TODO}
  \end{case}

  \begin{case}[ArrayAssignType]\label{arrayassigntype}
	\texttt{TODO}
  \end{case}

  \begin{case}[NumAssignType]\label{numassigntype}
	\texttt{TODO}
  \end{case}

  \begin{case}[PropNumAssignType]\label{propnumassigntype}
	\texttt{TODO}
  \end{case}

  \begin{case}[ArrayNumAssignType]\label{arraynumassigntype}
	\texttt{TODO}
  \end{case}

  \begin{case}[NumOpType]\label{numoptype}
	\texttt{TODO}
  \end{case}

  \begin{case}[booloptype]\label{booloptype}
	\texttt{TODO}
  \end{case}

  \begin{case}[CmpOpType]\label{cmpoptype}
	\texttt{TODO}
  \end{case}

  \begin{case}[NumCmpOpType]\label{numcmpoptype}
	\texttt{TODO}
  \end{case}

  \begin{case}[NegType]\label{negtype}
	\texttt{TODO}
  \end{case}

  \begin{case}[PreNumType]\label{prenumtype}
	\texttt{TODO}
  \end{case}

  \begin{case}[PostOpType]\label{postoptype}
	\texttt{TODO}
  \end{case}

\end{proof}



\section*{Preservation}

We want to show that typability is preserved by all possible transitions
in the language. We can show this by structural induction over the
derivation of the typability judgement for some statement $m$, using the
following induction hypothesis:


\end{document}
