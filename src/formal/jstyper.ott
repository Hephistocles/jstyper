% v0.4.1
% Version numbering: (project_goals_met?1:0).(added syntax).(refined spec)
metavar termvar, x, y, z, id, l, this, return ::=  
indexvar index, i, j, k ::= 


grammar

% syntax

v :: 'v_' ::=                                   {{ com Values }}
	| b         ::  :: Boolean 									{{ com Boolean }}
	| n         ::  :: Number 									{{ com Number }}
	| str       ::  :: String 									{{ com String }}
	| undefined ::  :: Undefined 								{{ com Undefined }}
	| null      ::  :: null 									{{ com null }}
	| eps  		::  :: EmptyStatement							{{ com EmptyStatement }}
																	{{ tex \epsilon }}
	| { l1 : v1 , .. , li : vi } ::  :: ObjVal					{{ com ObjVal }}
	| get( s , id ) :: M:: GetStore 							{{ com GetStore }}
	| func 		::  :: FuncVal 									{{ com FuncVal }} 

func :: 'func_' ::=
	| function id ( x1 , .. , xk ) { m } :: :: FunVal			{{ com FuncVal }}
	| function ( x1 , .. , xk ) { m } :: :: AnonFunVal			{{ com AnonFuncVal }}

s :: 's_' ::=                                   {{ com Store }}
	| put( s , [ id1 , .. , idi ] , [ v1 , .. , vk ] ) :: M:: PutStore 						{{ com PutStore }}
	| del( s , [ id1 , .. , idi ] ) :: M:: DelStore 							{{ com DelStore }}

vd :: 'vd_' ::=                                 {{ com VariableDeclaration }}
	| id        ::  :: Declaration 								{{ com Declaration }}
	| id = e    ::  :: Definition 								{{ com Definition }}

e :: 'e_' ::=                                   {{ com Expression }}
	| v         ::  :: Value 									{{ com Value }}
	| id        ::  :: Deref 									{{ com Deref }}
	| id Ass e  ::  :: Assign									{{ com Assign }}
	| e . l Ass e' ::  :: PropAssign							{{ com PropAssign }}
	| e op e'   ::  :: BinExp 									{{ com BinExp }}
	| e postOp  ::  :: PostExp 									{{ com PostExp }}
	| preOp e   ::  :: PreExp 									{{ com PreExp }}
	| { l1 : e1 , .. , li : ei } ::  :: ObjExp					{{ com ObjExp }}
	| e . l 	::  :: PropExp									{{ com PropExp }} 
	| e ( e1 , .. , e2 ) ::  :: CallExp							{{ com CallExp }} 

Ass :: 'a_' ::=	                                {{ com Assignments }}
				                                	{{ tex \approx }}
	| = 		::  :: PlainAssign                              {{ com PlainAssign }}
	| numOp =	::  :: NumAssign 								{{ com NumAssign }}

m :: 'm_' ::=                                   {{ com Statement }}
	| e         ::  :: Expression 								{{ com Expression }}
	| m1 ; .. ; mi    ::  :: Seqs          						{{ com Seqs }}
	| var vd1 , ... , vdk   ::  :: VarDeclaration 					{{ com VarDeclaration }}
	| if ( e ) { m1 }  ::  :: IfStatement						{{ com IfStatement }}
	| if ( e ) { m1 } else { m2 }  ::  :: IfElseStatement		{{ com IfElseStatement }}
	| return e  ::  :: ReturnStatement							{{ com ReturnStatement }}
	| return    ::  :: Return 									{{ com Return }}
	| { m } [ v1 / id1 , .. , vi / idi ] :: :: SubstStatement	{{ com SubstStatement (meta) }}
	| @def function id ( x1 , .. , xk ) { m } :: :: FuncDef		{{ com FuncDef }}

ret :: 'ret_' ::=
	| return e 	::  :: ReturnExp								{{ com ReturnExp }}
	| return 	::  :: Return 									{{ com Return }}

op :: 'op_' ::=                                 {{ com BinaryOperation }}
	| numOp  	::  :: NumOp 									{{ com NumOp }}
	| cmpOp 	::  :: CmpOp 									{{ com CmpOp }}
	| numcmpOp 	::  :: NumCmpOp									{{ com NumCmpOp }}
	| boolOp 	::  :: BoolOp									{{ com BoolOp }}


numOp :: 'nop_' ::=
	| + 		::  :: Addition                                 {{ com Addition }}
	| - 		::  :: Subtraction                              {{ com Subtraction }}
	| / 		::  :: Division                                 {{ com Division }}
	| * 		::  :: Multiplication                           {{ com Multiplication }}
	| % 		::  :: Modulo                                   {{ com Modulo }}


numcmpOp :: 'ncop_' ::=
	| < 		::  :: LessThan                                 {{ com LessThan }}
	| > 		::  :: GreaterThan                              {{ com GreaterThan }}
	| <= 		::  :: LessEqual                                {{ com LessEqual }}
																	{{ tex \leq }}
	| >= 		::  :: GreaterEqual                             {{ com GreaterEqual }}
																	{{ tex \geq }}

cmpOp :: 'cop_' ::=
	| == 		::  :: Equal                                    {{ com Equal }}
	| != 		::  :: Unequal                                  {{ com Unequal }}
																	{{ tex !\!\!= }}
	| === 		::  :: StrictEqual                              {{ com StrictEqual }}
	| !== 		::  :: StrictUnequal                            {{ com StrictUnequal }}
																	{{ tex !\!\!== }}
boolOp :: 'bop_' ::=
	| || 		::  :: BooleanOr                                {{ com BooleanOr }}
	| && 		::  :: BooleanAnd                               {{ com BooleanAnd }}

preOp :: 'preop_' ::=                           {{ com PrefixOperation }}
	| preNum 	::  :: PreNum 									{{ com PreNum }}
	| !			::  :: BoolNegation                             {{ com BoolNegation }}
																	{{ tex !\! }}

preNum :: 'prenum_' ::=                           {{ com PreNum }}
	| ~ 		::  :: Negation                                 {{ com Negation }}
																	{{ tex -\! }}
	| --		::  :: PreDecrement                             {{ com PreDecrement }}
																	{{ tex -\!\!-\!\! }}
	| ++		::  :: PreIncrement                             {{ com PreIncrement }}
																	{{ tex +\!\!+\!\! }}

postOp :: 'postop_' ::=                         {{ com PostfixOperation }}
	| --		::  :: PostDecrement                             {{ com PostDecrement }}
																	{{ tex \!\!\!-\!\!- }}
	| ++		::  :: PostIncrement                             {{ com PostIncrement }}
																	{{ tex \!\!+\!\!+ }}

% Typing definitions

b :: 'b_' ::=
	| true		::  :: True
	| false		::  :: False

T :: 'Tval_' ::=				                {{ com Value Type }}
	| number    ::  :: Number 									{{ com Number }}
	| boolean   ::  :: Boolean 									{{ com Boolean }}
	| string    ::  :: String 									{{ com String }}
	| undefined ::  :: undefined 								{{ com undefined }}
	| null      ::  :: null 									{{ com null }}
	| { l1 : T1 , .. , li : Ti } ::  :: ObjType					{{ com ObjType }}
	| T1 , ... , Ti -> Tj ::   :: FunType						{{ com FunType }}
	| G ["return"] :: :: GammaType 								{{ com GammaType }} 

G {{ tex \Gamma }} :: 'G_' ::= 					{{ com Context }}
	| \{}		::  :: EmptyContext								{{ com EmptyContext }}
	| { G }		::  :: SingletonContext							{{ com SingletonContext }}
	| G u G'	::  :: UnionContext								{{ com UnionContext }}
																	{{ tex [[G]] \cup [[G']] }}
	| id : T 	::  :: ContextItem								{{ com ContextItem }}
	| { id1 : T1 , .. , idk : Tk } 	::  :: ContextItems			{{ com ContextItems }}

C :: 'C_' ::= 					                {{ com Constraint }}
	| \{}		 ::  :: EmptyConstraint							{{ com EmptyConstraint }}
	| C u C'	 ::  :: UnionConstraint							{{ com UnionConstraint }}
																	{{ tex [[C]] \cup [[C']] }}
	| C n C'	 ::  :: IntersectConstraint						{{ com IntersectConstraint }}
																	{{ tex [[C]] \cap [[C']] }}
	| U setIndex = n1 - n2 C :: :: BigUnion 						{{ com BigUnion }}
																	{{ tex \bigcup \limits_{i=[[n1]]}^[[n2]] [[C]] }}
	| { T1 < T2 } ::  :: ConstLeq 										{{ com ConstLeq }}
																	{{ tex \{ [[T1]] \preceq [[T2]] \} }}
	| { T1 > T2 } ::  :: ConstGeq				 						{{ com ConstGeq }}
																	{{ tex \{ [[T1]] \succeq [[T2]] \} }}
	| ( C )		 ::  :: BracketedConstraint  					{{ com BracketedConstraint }}
																	{{ tex [[C]] }}
	| ` C `		 ::  :: EnforcedConstraint  					{{ com EnforcedConstraint }}
																	{{ tex \underline{[[C]]} }}

terminals :: 'terminals_' ::=
	| ->        ::  :: rightarrow 									{{ tex \rightarrow }}
	| G         ::  :: Gamma                						{{ tex \Gamma }}
	| |-        ::  :: Entails              						{{ tex \vdash }}
	| ;         ::  :: semicolon
	| var       ::  :: var
	| \{}		::  :: emptyset             						{{ tex \varnothing }}

sv :: 'sv_' ::= 								{{ com SetVar }}
	| C 		::  :: ConstraintSet						    {{ com ConstraintSet }}
	| X 		::  :: VariableSet							    {{ com VariableSet }}
	| dom( G )	::  :: dom
	| codom( G ) ::  :: codom

fv :: 'fv_' ::= 								{{ com FormulaVar }}
	| G 		::  :: ContextVar							    {{ com ContextVar }}
	| G ( id )  ::  :: ContextMember							{{ com ContextMember }}
	| sv 		::  :: SetFormulaVar							{{ com SetFormulaVar }}
	| T 		::  :: TypeFormulaVar							{{ com TypeFormulaVar }}
	| id 		::  :: IDFormulaVar								{{ com IDFormulaVar }}
	| func  	::  :: FuncFormulaVar							{{ com FuncFormulaVar }}
	| e 		::  :: ExpFormulaVar                            {{ com ExpFormulaVar }}

n :: 'n_' ::=
	| 0			::  :: Zero
	| 1			::  :: One
	| 2			::  :: Two
	| 3			::  :: Three
	| setIndex  ::  :: SetIndex

setIndex :: 'ix_' ::=
	| i 		::  :: i
	| k 		::  :: k
	| j 		::  :: j

formula :: formula_ ::=  
   |  judgement                       ::  :: judgement         {{ com judgement }}
   |  not formula                     ::  :: not               {{ com not }}
   															    	{{ tex \neg [[formula]] }} 
   |  ( formula )                     ::  :: brackets          {{ com brackets }}
   															    	{{ tex ([[formula]]\!) }}  
   |  [ formula ]                     ::  :: bracketsHidden    {{ com bracketsHidden }}
   															    	{{ tex [[formula]] }}  
   |  formula1 --- formulak           ::  :: listForm          {{ com listForm }}
   															    	{{ tex [[formula1]] \hdots [[formulak]] }}
   |  formula \/ formula’             ::  :: or                {{ com or }}
   															    	{{ tex [[formula]] \vee [[formula’]] }}
   |  formula /\ formula’             ::  :: and               {{ com and }}
   															    	{{ tex [[formula]] \wedge [[formula’]] }}
   |  formula for formula' 			  ::  :: condform          {{ com condform }}
   																	{{ tex [[formula]] \hspace{1pc}\textit{for}\hspace{6pt} [[formula']] }}
   |  A setIndex formula 			  ::  :: ForAll				{{ com ForAll }}
   																	{{ tex \forall [[setIndex]][[formula]]}}
   |  A setIndex in sv formula 		  ::  :: ForAllIn			{{ com ForAllIn }}
   																	{{ tex \forall [[setIndex]]\in[[sv]][[formula]]}}
   |  fv = fv2                        ::  :: fequal 			{{ com fequal }}
   |  fv != fv2                       ::  :: fnotequal 			{{ com fnotequal }}
   																	{{ tex [[fv]] \neq [[fv2]] }}
   |  fv in sv2		 	              ::  :: Contains			{{ com Contains }}
																	{{ tex [[fv]] \in [[sv2]] }}
   |  fv !in sv2	 	              ::  :: NotContains		{{ com NotContains }}
																	{{ tex [[fv]] \notin [[sv2]] }}
	| T is fresh 					::  :: Fresh 			{{ com Fresh }} 
	| T1 , .. , Ti are fresh 					::  :: Freshs 			{{ com Freshs }} 



defns
Jop :: '' ::=

	defn
	< m , s > -> < m' , s' > :: ::reduce::''  
	{{ tex \langle [[m]], [[s]] \rangle [[->]] \langle [[m']], [[s']] \rangle }}
	by

		-------------------                        		            ::   Seq1
		<v; m1; ..; mi, s> -> <m1; ..; mi, s>

		<m1, s> -> <m1', s'>
		----------------------------              		            ::   Seq2
		<m1;m2; ..; mi, s> -> <m1'; m2; ..; mi, s'>

		<e, s> -> <e', s'>
		----------------------------                 		        ::   Assign1
		<id Ass e, s> -> <id Ass e', s'>

		---------------------------------            		        ::   Assign
		<id = v, s> -> <v, put(s, [id], [v])>

		----------------------------                 		        ::   AssignNum
		<id numOp= v, s> -> <id = id numOp v, s>

		--------------------------                  		        ::   Deref
		<id, s> -> <get(s, id), s>

		-----------------------------                		        ::   Var1
		<var id, s> -> <eps, s>

		<e, s> -> <e', s'>
		-----------------------------------               		    ::   Var2
		<var id = e, s> -> <var id = e', s>

		----------------------------------------       		        ::   Var3
		<var id = v, s> -> <eps, put(s, [id], [v])>

		----------------------------------------- 			        ::   Var4
		<var vd, vd', s> -> <var vd; var vd', s >

		------------------------------------------------- 			::   FuncDef
		<@def function x(y1,..,yi) {m}, s> -> <eps, put(s, [x], [function (y1,..,yi) {m}])> 

		<e, s> -> <e', s'>
		--------------------------------                            ::   UnOp1
		<preOp e1, s> -> <preOp e1', s'>

		<e, s> -> <e', s'>
		--------------------------------                            ::   UnOp2
		<e1 postOp, s> -> <e1' postOp, s'>

		<e1, s> -> <e1', s'>
		--------------------------------                            ::   BinOp1
		<e1 op e2, s> -> <e1' op e2, s'>

		<e2, s> -> <e2', s'>
		-------------------------------                             ::   BinOp2
		<v op e2, s> -> <v op e2', s'>

		n1 op n2 = n
		-----------------------                                     ::   BinOp3
		<n1 op n2, s> -> <n, s>

		!b1 = b2
		-----------------------                                     ::   BoolNeg
		<!b1, s> -> <b2, s>

		~n1 = n
		-----------------------                                     ::   NumNeg
		<~n1, s> -> <n, s>

		get(s, id) + 1 = v
		-----------------------------                               ::   PostInc
		<id++, s> -> <id, put(s, [id], [v])>

		get(s, id) + 1 = v
		-----------------------------                               ::   PreInc
		<++id, s> -> <id+1, put(s, [id], [v])>

		get(s, id) - 1 = v
		-----------------------------                               ::   PostDec
		<id--, s> -> <id, put(s, [id], [v])>

		get(s, id) - 1 = v
		-----------------------------                               ::   PreDec
		<--id, s> -> <id+1, put(s, [id], [v])>

		<e, s> -> <e', s'>
		--------------------------------------------------------    ::	 If1
		<if (e) {m1} else {m2}, s> -> <if (e') {m1} else {m2}, s'>

		--------------------------------------		                ::	 If2
		<if (true) {m1} else {m2}, s> -> <m1, s>

		--------------------------------------		                ::	 If3
		<if (false) {m1} else {m2}, s> -> <m2, s>
		
		--------------------------------------------------------    ::	 If4
		<if (e) {m1}, s> -> <if (e) {m1} else {}, s'>

		% TODO: Need to get a line break in here...
		<e, s> -> <e', s'>
		---------------------------------------------				::   Obj
		< {l1: v1, .., lj: vj, l: e, l1': e1', .., lj': ej'}, s> -> <{l1: v1, .., lj: vj, l: e', l1': e1', .., lj': ej'}, s'>

		<e, s> -> <e', s'>
		----------------------- 									::   Prop1
		<e.l, s> -> <e'.l, s'>

		----------------------- 									::   Prop2
		< {l1: v1, .., lj: vj, l: v, l1': v1', .., lj': vj'}.l, s> -> <v, s'>

		<e, s> -> <e', s'>
		----------------------- 									::   Call1
		< e(e1,..,ei), s> -> <e'(e1,..,ei), s'>

		<e1, s> -> <e1', s'>
		----------------------- 									::   Call2
		< v(v1,..,vi,e1,e2,..,ej), s> -> <v(v1,..,vi,e1',e2,..,ej), s'>

		<m, put( s, [id, x1,..,xi], [function id(x1,..,xi){m},v1,..,vi])> -> <return v; m', s'>
		----------------------- 									::   Call3
		< function id(x1,..,xi){m}(v1,..,vi), s> -> <v, del(s', [id,x1,..,xi])>

		<m, put( s, [x1,..,xi], [v1,..,vi])> -> <return v; m', s'>
		----------------------- 									::   Call4
		<function (x1,..,xi){m}(v1,..,vi), s> -> <v, del(s', [x1,..,xi])>

		<v.l,s> -> <function id (x1,..,xi){m}, s'>
		--------------------------------------------------------- 	:: 	PropCall
		<v.l(e1,..,ei),s> -> <function id (this,x1,..,xi){m}(v,e1,..,ei), s'>

	defn
	G |- e : T | C G' :: ::expType::''
	 {{ tex [[G]] [[|-]] [[e]] : [[T]]\hspace{5pt}| _{ [[C]] } \hspace{5pt} [[G']] }}
	 by
		% Note: Only expressions have a type - the more general statements do not

		% typing rules for values

		-------------------------                           		:: V_Num
		G |- n : number |\{} G

		--------------------------                          		:: V_Bool
		G |- b : boolean |\{} G

		---------------------------                         		:: V_String
		G |- str : string |\{} G

		------------------------------------                		:: V_Undefined
		G |- undefined : undefined |\{} G

		--------------------------                          		:: V_Null
		G |- null : null |\{} G

		------------------------------                     		    :: V_Skip
		G |- eps : undefined |\{} G
	
		G |- e1 : T1 | C1 G1 --- Gk-1 |- ek : Tk | Ck Gk 
		C = (U i=1-k Ci) u (U i=1-k {Ti < Ti'})
		T1', .., Tk' are fresh
		---------------------------------------------------------   :: V_Obj
		G |- {l1: e1, .., lk: ek} : {l1: T1', .., lk: Tk'} |C Gk

		% TODO: Case when G'["return"] doesn't exist

		T0, T1, .., Ti are fresh
		G u {this: T0, x1:T1, .., xi:Ti} |- m1; ..; mj |C G'
		----------------------------------------------------------------------- :: V_Fun1
		G |- function (x1, .., xi) { m1; ..; mj } : T0, T1, .., Ti -> T |C u {G'["return"] < T} G

		T0, T1, .., Ti are fresh
		G u {this: T0, x1:T1, .., xi:Ti, id:T1, .., Ti -> T} |- m1; ..; mj |C G'
		----------------------------------------------------------------------- :: V_Fun2
		G |- function id(x1, .., xi) { m1; ..; mj } : T0, T1, .., Ti -> T |C u {G'["return"] < T} G


		% Variable retrieval

		G(id) = T
		---------------------		                                :: IdType
		G |- id : T |\{} G

		id !in dom(G)
		T is fresh
		----------------------------------- 						:: IdTypeUndef
		G |- id : T |\{} G u {id : T}

		G |- e : T1 |C G1
		T2 is fresh
		---------------------------------------------------------   :: PropType
		G |- e.l : T2 |C u {{l:T2} < T1} G1
	


		% Function Calls

		% I'm saying this is {} if unspecified (in practice this is global object e.g. window)

		G |- e : {}, T1, .., Ti -> T |C0 G0
		G0 |- e1 : T1' |C1 G1 --- Gk-1 |- ei : Ti' |Ci Gi
		C' = (U i=0-k Ci) u (U i=1-k {Ti < Ti'})
		-------------------------------------------------- 			:: CallType
		G |- e(e1,..,ei) : T |C' Gi

		G |- e : T0' |C0 G'
		G' |- e.l : T0, T1, .., Ti -> T |C0 G0
		G0 |- e1 : T1' |C1 G1 --- Gk-1 |- ei : Ti' |Ci Gi
		C' = ((U i=0-k Ci) u (U i=1-k {Ti < Ti'})) u {T0' < T0}
		-------------------------------------------------- 			:: PropCallType
		G |- e.l(e1,..,ei) : T |C' Gi



		% Assignment operations

		G |- e : T1 |C1 G1
		G1 |- id : T2 |C2 G2
		------------------------------------------------------	 	:: AssignType 
		G |- id = e : T1 |(C1 u C2) u { T2 < T1 } G2

		G |- e' : T1 |C1 G1
		G1 |- e : T2 |C2 G2
		------------------------------------------------------	 	:: PropAssignType
		G |- e.l = e' : T1 |(C1 u C2) u `{ {l:T1} < T2 }` G2

		G |- e : T1 |C1 G1
		G1 |- id : T2 |C2 G2
		------------------------------------------------------	 	:: NumAssignType
		G |- id numOp= e : T1 |(C1 u C2) u ({ T2 < T1 } u {T1 < number}) G2



		% Mathematical Binary Operations

		G |- e1 : T1 |C1 G1
		G1 |- e2 : T2 |C2 G2
		------------------------------------------------------------  :: NumOpType
		G |- e1 numOp e2 : number |(C1 u C2) u ({T1 < number} u {T2 < number}) G2




		% Boolean Binary operations

		G |- e1 : T1 |C1 G1
		G1 |- e2 : T2 |C2 G2
		------------------------------------------------------------  :: BoolOpType
		G |- e1 boolOp e2 : boolean | (C1 u C2) u ({T1 < boolean} u {T2 < boolean}) G2



		% Equality Operations

		G |- e1 : T1 |C1 G1
		G1 |- e2 : T2 |C2 G2
		-------------------------------------------------------		  :: CmpOpType
		G |- e1 cmpOp e2 : boolean |(C1 u C2) u {T1 < T2} G2

		G |- e1 : T1 |C1 G1
		G1 |- e2 : T2 |C2 G2
		-------------------------------------------------------		  :: NumCmpOpType
		G |- e1 numcmpOp e2 : boolean |(C1 u C2) u ({T1 < T2} u {T1 < number}) G2


		% Unary Operation

		G |- e : T1 |C G'
		------------------------------------------- 	:: NegType
		G |- !e : boolean |C u {T1 < boolean} G'

		G |- e : T1 |C G'
		------------------------------------------- 	:: PreNumType
		G |- preNum e : number |C u {T1 < number} G'

		G |- e : T1 |C G'
		------------------------------------------- 	:: PostOpType
		G |- e postOp : number |C u {T1 < number} G'


	defn
	G |- m | C G' :: :: typable::'' 
	 {{ tex [[G]] [[|-]] [[m]] \hspace{5pt}| _{ [[C]] } \hspace{5pt} [[G']]}}
	 by
		% We say that a statement m is typable if all expressions contained within it are well typed by the definition above.

		G |- e : T |C G'
		-------------------                                		    :: ExpTypable
		G |- e |C G'

		G |- e : T |C G'
		return !in dom(G)
		-------------------                                		    :: RetTypable1
		G |- return e |C G' u {return: T}

		% Check constraint direction...
		G |- e : T |C G'
		return in dom(G)
		-------------------                                		    :: RetTypable2
		G |- return e |C u {T < G["return"]} G' 

		return !in dom(G)
		-------------------                                		    :: RetTypable3
		G |- return |\{} G u {return: undefined}

		return in dom(G)
		-------------------                                		    :: RetTypable4
		G |- return |{undefined < G["return"]} G

		G |- m1 |C1 G1 --- Gi-1 |- mi |Ci Gi
		C = U i=0-k Ci
		---------------------------------                		    :: SeqTypable
		G |- m1; ...; mi |C Gi

		G |- e : T1 |C1 G1
		G1 |- m1 |C2 G2
		G1 |- m2 |C3 G3
		---------------------------------                		    :: IfTypable1
		G |- if (e) {m1} else {m2} |(C1 u (C2 u C3)) u {T1 < boolean} G1

		G |- e : T1 |C1 G1
		G1 |- m1 |C2 G2
		---------------------------------                		    :: IfTypable2
		G |- if (e) {m1} |(C1 u C2) u {T1 < boolean} G1

		T is fresh
		---------------------------------                		    :: DecTypable
		G |- var id |\{} G u {id : T}

		G |- e : T |C G'
		T' is fresh
		---------------------------------                		    :: DefTypable
		G |- var id = e |C u {T' < T} G' u {id : T'}

		G |- var vd1 |C1 G1 --- Gk-1 |- var vdk |Ck Gk
		C = (U i=i-k Ck)
		---------------------------------------            		    :: MultiDecTypable
		G |- var vd1,...,vdk |C G2
