% v0.1.3
% Version numbering: (project_goals_met?1:0).(added syntax).(refined spec)
grammar

% syntax

id :: 'id_' ::=

v :: 'v_' ::=                                   {{ com Values }}
	| b         ::  :: Boolean 									{{ com Boolean }}
	| n         ::  :: Number 									{{ com Number }}
	| str       ::  :: String 									{{ com String }}
	| undefined ::  :: Undefined 								{{ com Undefined }}
	| null      ::  :: null 									{{ com null }}
	| eps  		::  :: EmptyStatement							{{ com EmptyStatement }}
																{{ tex \epsilon }}
	| get( s , id ) :: M:: GetStore 							{{ com GetStore }}

s :: 's_' ::=                                   {{ com Store }}
	|  put( s , id , v ) :: M:: PutStore 						{{ com PutStore }}

vd :: 'vd_' ::=                                 {{ com VariableDeclaration }}
	| id        ::  :: Declaration 								{{ com Declaration }}
	| id = e    ::  :: Definition 								{{ com Definition }}
	| vd , vd'  ::  :: Multiple 								{{ com Multiple }}

e :: 'e_' ::=                                   {{ com Expression }}
	| v         ::  :: Value 									{{ com Value }}
	| id        ::  :: Deref 									{{ com Deref }}
	| id = e    ::  :: Ref 										{{ com Ref }}

m :: 'm_' ::=                                   {{ com Statement }}
	| e         ::  :: Expression 								{{ com Expression }}
	| m ; m'    ::  :: Seq          							{{ com Seq }}
	| var vd    ::  :: VarDeclaration 							{{ com VarDeclaration }}

% Typing definitions
% TODO: We will need to do something clever here to allow for object types

T :: 'Tval_' ::=				                {{ com Value Type }}
	| number    ::  :: Number 									{{ com Number }}
	| boolean   ::  :: Boolean 									{{ com Boolean }}
	| string    ::  :: String 									{{ com String }}
	| undefined ::  :: undefined 								{{ com undefined }}
	| null      ::  :: null 									{{ com null }}

% T :: 'T_' ::=                                   {{ com Expression Type }}
	%| Tv 		::  :: ValueType								{{ com ValueType }}
	%| ref< Tv > ::  :: RefType									{{ com Location Type }}
								            					%{{ tex ref \langle [[Tv]] \rangle}}
	

% Things Ott wants

G {{ tex \Gamma }} :: 'G_' ::= 					{{ com Context }}
	| {}		::  :: EmptyContext								{{ com EmptyContext }}
	| { G }		::  :: SingletonContext							{{ com SingletonContext }}
	| G u G'	::  :: UnionContext								{{ com UnionContext }}
																{{ tex [[G]] \cup [[G']] }}
	| id : T 	::  :: ContextItem								{{ com ContextItem }}

R :: 'R_' ::=					                {{ com Relations }}
	| =			::  :: Equals									{{ com Equals }}
	| != 		::  :: NotEquals								{{ com NotEquals }}
	| contains 	::  :: Contains									{{ com Contains }}
																{{ tex \in }}
	| !contains ::  :: NotContains 								{{ com NotContains }}
																{{ tex \notin }}

Eq :: 'Eq' ::=					                {{ com Equations }}
	| Eq R Eq'  ::  :: Equality	 								{{ com com Equality }}
	| C 		::  :: ConstraintFormula						{{ com ConstraintFormula }}
	| G 		::  :: ContextFormula							{{ com ContextFormula }}
	| X 		::  :: VariableFormula							{{ com VariableFormula }}
	| T 		::  :: TypeFormula								{{ com TypeFormula }}
	| id 		::  :: IDFormula								{{ com IDFormula }}
	| func  	::  :: FuncFormula								{{ com FuncFormula }}

C :: 'C_' ::= 					                {{ com Constraint }}
	| {}		::  :: EmptyConstraint							{{ com EmptyConstraint }}
	| C u C'	::  :: UnionConstraint							{{ com UnionConstraint }}
																{{ tex [[C]] \cup [[C']] }}
	| C n C'	::  :: IntersectConstraint						{{ com IntersectConstraint }}
																{{ tex [[C]] \cap [[C']] }}
	| { Eq }	::  :: ConstraintEquation 						{{ com ConstraintEquation }}
	| ( C )		::  :: BracketedConstraint  					{{ com BracketedConstraint }}
																{{ tex [[C]] }}

X :: 'X_' ::= 					                {{ com Variable }}
	| {}		::  :: EmptyVariable							{{ com EmptyVariable }}
	| { T }		::  :: SingletonVariable						{{ com SingletonVariable }}
	| X u X'	::  :: UnionVariable							{{ com UnionVariable }}
																{{ tex [[X]] \cup [[X']] }}
	| X n X'	::  :: IntersectVariable						{{ com IntersectVariable }}
																{{ tex [[X]] \cap [[X']] }}
	| FV( T )	::  :: FreeVars									{{ com FreeVars }}											

func :: 'func_' ::=				                {{ com Function }}
	| dom( G )	::  :: dom

terminals :: 'terminals_' ::=
	| ->        ::  :: rightarrow 								{{ tex \rightarrow }}
	| G         ::  :: Gamma                					{{ tex \Gamma }}
	| |-        ::  :: Entails              					{{ tex \vdash }}
	| ;         ::  :: semicolon
	| var       ::  :: var
	| {}		::  :: emptyset             					{{ tex \varnothing }}


defns
Jop :: '' ::=

defn
G ( id ) = T :: M::expType2::''  by
	
defn 
Eq 	:: M::ConstraintEq::'' by

defn
< m , s > -> < m' , s' > :: ::reduce::''  
{{ tex \langle [[m]], [[s]] \rangle [[->]] \langle [[m']], [[s']] \rangle }}
by

	-------------------                        		            ::   Seq1
	<v; m, s> -> <m, s>

	<m1, s> -> <m1', s'>
	----------------------------              		            ::   Seq2
	<m1; m2, s> -> <m1'; m2, s'>

	<e, s> -> <e', s'>
	----------------------------                 		        ::   Assign1
	<id = e, s> -> <id = e', s'>

	---------------------------------            		        ::   Assign2
	<id = v, s> -> <v, put(s, id, v)>

	--------------------------                  		        ::   Deref
	<id, s> -> <get(s, id), s>

	-----------------------------                		        ::   Var1
	<var id, s> -> <eps, s>

	<e, s> -> <e', s'>
	-----------------------------------               		    ::   Var2
	<var id = e, s> -> <var id = e', s>

	-------------------------------               		        ::   Var3
	<var id = v, s> -> <eps, s>

	----------------------------------------- 			        ::   Var4
	<var vd, vd', s> -> <var vd; var vd', s >

defn
G |- e : T | X C , G' :: ::expType::''
 {{ tex [[G]] [[|-]] [[e]] : [[T]]\hspace{5pt}| _{ [[X]] } \hspace{3pt}[[C]], [[G']] }}
 by
	% Note: Only expressions have a type - the more general statements do not

	% Trivial typing rules for values

	-------------------------                           		:: v_num
	G |- n : number |{} {}, G

	--------------------------                          		:: v_bool
	G |- b : boolean |{} {}, G

	---------------------------                         		:: v_string
	G |- str : string |{} {}, G

	------------------------------------                		:: v_undefined
	G |- undefined : undefined |{} {}, G

	--------------------------                          		:: v_ull
	G |- null : null |{} {}, G

	------------------------------                     		    :: V_Skip
	G |- eps : undefined |{} {}, G
	
	G(id) = T
	---------------------		                                :: IdType
	G |- id : T |{} {}, G

	id !contains dom(G)
	----------------------------------- 						:: IdTypeUndef
	G |- id : T |{ T } {}, G u {id : T}


	% Note I'm enforcing that the expression have a value type
	% Note we might be worried here about typing things like ref<ref<T>> but that can't occur in JavaScript
	              G |- e : T1 |X1 C1, G1               		
	             G1 |- id : T2 |X2 C2, G2               		
	                   X1 n X2 = {}                     		
	------------------------------------------------------	 	:: AssignType
	G |- id = e : T2 |X1 u X2 (C1 u C2) u { T2 = T1 }, G2

defn
G |- m | X C , G' :: :: typable::'' 
 {{ tex [[G]] [[|-]] [[m]] \hspace{5pt}| _{ [[X]] } \hspace{3pt}[[C]], [[G']]}}
 by
	% We say that a statement m is typable if all expressions contained within it are well typed by the definition above.

	% NB We're going to need to do something to model scope within G

	---------------------------------                		    :: DecTypable
	G |- var id |{T} {}, G u {id : T}

	G |- e : T |X C, G'
	-------------------                                		    :: ExpTypable
	G |- e |X C, G'

	G |- m1 |X1 C1, G1
	G1 |- m2 |X2 C2, G2
	X1 n X2 = {}
	---------------------------------                		    :: SeqTypable
	G |- m1 ; m2 |X1 u X2 C1 u C2, G2
	
	% NB DefTypable is dubious because we type it with assignment where the AST treats it as separate.
	% Fixing it would involve making 'var id' an expression though, which would be worse.

	G |- var id | X1 C, G1
	G1 |- id = e : T |X2 C, G2
	X1 n X2 = {}
	---------------------------------                		    :: DefTypable
	G |- var id = e |X1 u X2 C1 u C2, G2


	G |- var vd |X1 C1, G1
	G1 |- var vd' |X1 C2, G2
	X1 n X2 = {}
	---------------------------------------            		    :: MultiDecTypable
	G |- var vd , vd' |X1 u X2 C1 u C2, G2
