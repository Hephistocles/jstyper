% v1.0.0
% Version numbering: (project_goals_met?1:0).(added syntax).(refined spec)
metavar termvar, x, y, z, id, l, this, return ::=  
indexvar index, i, j, k ::= 


grammar

% syntax

v :: 'v_' ::=                                   {{ com Values }}
	| b         ::  :: Boolean 									{{ com Boolean }}
	| n         ::  :: Number 									{{ com Number }}
	| str       ::  :: String 									{{ com String }}
	| undefined ::  :: Undefined 								{{ com Undefined }}
	| null      ::  :: null 									{{ com null }}
	| { l1 : v1 , .. , li : vi } ::  :: ObjVal					{{ com ObjVal }}
	| func 		::  :: FuncVal 									{{ com FuncVal }} 
	| [ v1 , .. , v2 ] ::  :: ArrayVal 							{{ com ArrayVal }}
	| get( s , id ) :: M:: GetStore 							{{ com GetStore }}

func :: 'func_' ::=
	| function id ( x1 , .. , xk ) { m } :: :: FunVal			{{ com FuncVal }}
	| function ( x1 , .. , xk ) { m } :: :: AnonFunVal			{{ com AnonFuncVal }}

s :: 's_' ::=                                   {{ com Store }}
	| put( s , [ id1 , .. , idi ] , [ v1 , .. , vk ] ) :: M:: PutStore 						{{ com PutStore }}
	| del( s , [ id1 , .. , idi ] ) :: M:: DelStore 							{{ com DelStore }}

vd :: 'vd_' ::=                                 {{ com VariableDeclaration }}
	| id        ::  :: Declaration 								{{ com Declaration }}
	| id = e    ::  :: Definition 								{{ com Definition }}

e :: 'e_' ::=                                   {{ com Expression }}
	| v         ::  :: Value 									{{ com Value }}
	| id        ::  :: Deref 									{{ com Deref }}
	| id Ass e  ::  :: Assign									{{ com Assign }}
	| e . l Ass e' ::  :: PropAssign							{{ com PropAssign }}
	| e1 [ e2 ] Ass e  ::  :: ArrayAssign						{{ com ArrayAssign }}
	| e op e'   ::  :: BinExp 									{{ com BinExp }}
	| e postOp  ::  :: PostExp 									{{ com PostExp }}
	| preOp e   ::  :: PreExp 									{{ com PreExp }}
	| { l1 : e1 , .. , li : ei } ::  :: ObjExp					{{ com ObjExp }}
	| e . l 	::  :: PropExp									{{ com PropExp }} 
	| e [ e1 ] 	::  :: ArrExp									{{ com ArrExp }} 
	| e ( e1 , .. , e2 ) ::  :: CallExp							{{ com CallExp }} 
	| [ e1 , .. , e2 ] ::  :: ArrayExp 							{{ com ArrayExp }}

Ass :: 'a_' ::=	                                {{ com Assignments }}
				                                	{{ tex \approx }}
	| = 		::  :: PlainAssign                              {{ com PlainAssign }}
	| numOp =	::  :: NumAssign 								{{ com NumAssign }}

varDec :: 'vd_' ::=
	| var vd1 , ... , vdk   ::  :: VarDeclaration 				{{ com VarDeclaration }}

m :: 'm_' ::=                                   {{ com Statement }}
	| e         ::  :: Expression 								{{ com Expression }}
	| m1 ; .. ; mi    ::  :: Seqs          						{{ com Seqs }}
	| varDec  ::  :: VarDeclaration								{{ com VarDeclaration }}
	| if ( e ) { m1 }  ::  :: IfStatement						{{ com IfStatement }}
	| if ( e ) { m1 } else { m2 }  ::  :: IfElseStatement		{{ com IfElseStatement }}
	| return e  ::  :: ReturnStatement							{{ com ReturnStatement }}
	| return    ::  :: Return 									{{ com Return }}
	| @def function id ( x1 , .. , xk ) { m } :: :: FuncDef		{{ com FuncDef }}
	| while ( e ) { m1 } ::  :: WhileStatement 					{{ com WhileStatement }} 
	| for ( e1 ; e2 ; e3 ) { m1 } ::  :: ForStatement1 			{{ com ForStatement1 }} 
	| for ( varDec ; e2 ; e3 ) { m1 } ::  :: ForStatement2 		{{ com ForStatement2 }} 
	| eps  		::  :: EmptyStatement							{{ com EmptyStatement }}
																	{{ tex \epsilon }}
ret :: 'ret_' ::=
	| return e 	::  :: ReturnExp								{{ com ReturnExp }}
	| return 	::  :: Return 									{{ com Return }}

op :: 'op_' ::=                                 {{ com BinaryOperation }}
	| numOp  	::  :: NumOp 									{{ com NumOp }}
	| cmpOp 	::  :: CmpOp 									{{ com CmpOp }}
	| numcmpOp 	::  :: NumCmpOp									{{ com NumCmpOp }}
	| boolOp 	::  :: BoolOp									{{ com BoolOp }}


numOp :: 'nop_' ::=
	| + 		::  :: Addition                                 {{ com Addition }}
	| - 		::  :: Subtraction                              {{ com Subtraction }}
	| / 		::  :: Division                                 {{ com Division }}
	| * 		::  :: Multiplication                           {{ com Multiplication }}
	| % 		::  :: Modulo                                   {{ com Modulo }}


numcmpOp :: 'ncop_' ::=
	| < 		::  :: LessThan                                 {{ com LessThan }}
	| > 		::  :: GreaterThan                              {{ com GreaterThan }}
	| <= 		::  :: LessEqual                                {{ com LessEqual }}
																	{{ tex \leq }}
	| >= 		::  :: GreaterEqual                             {{ com GreaterEqual }}
																	{{ tex \geq }}

cmpOp :: 'cop_' ::=
	| == 		::  :: Equal                                    {{ com Equal }}
	| != 		::  :: Unequal                                  {{ com Unequal }}
																	{{ tex !\!\!= }}
	| === 		::  :: StrictEqual                              {{ com StrictEqual }}
	| !== 		::  :: StrictUnequal                            {{ com StrictUnequal }}
																	{{ tex !\!\!== }}
boolOp :: 'bop_' ::=
	| || 		::  :: BooleanOr                                {{ com BooleanOr }}
	| && 		::  :: BooleanAnd                               {{ com BooleanAnd }}

preOp :: 'preop_' ::=                           {{ com PrefixOperation }}
	| preNum 	::  :: PreNum 									{{ com PreNum }}
	| !			::  :: BoolNegation                             {{ com BoolNegation }}
																	{{ tex !\! }}

preNum :: 'prenum_' ::=                           {{ com PreNum }}
	| ~ 		::  :: Negation                                 {{ com Negation }}
																	{{ tex -\! }}
	| --		::  :: PreDecrement                             {{ com PreDecrement }}
																	{{ tex -\!\!-\!\! }}
	| ++		::  :: PreIncrement                             {{ com PreIncrement }}
																	{{ tex +\!\!+\!\! }}

postOp :: 'postop_' ::=                         {{ com PostfixOperation }}
	| --		::  :: PostDecrement                             {{ com PostDecrement }}
																	{{ tex \!\!\!-\!\!- }}
	| ++		::  :: PostIncrement                             {{ com PostIncrement }}
																	{{ tex \!\!+\!\!+ }}

% Typing definitions

b :: 'b_' ::=
	| true		::  :: True
	| false		::  :: False

T :: 'Tval_' ::=				                {{ com Value Type }}
	| number    ::  :: Number 									{{ com Number }}
	| boolean   ::  :: Boolean 									{{ com Boolean }}
	| string    ::  :: String 									{{ com String }}
	| undefined ::  :: undefined 								{{ com undefined }}
	| null      ::  :: null 									{{ com null }}
	| { l1 : T1 , .. , li : Ti } ::  :: ObjType					{{ com ObjType }}
	| ( T1 , ... , Ti -> Tj ) ::   :: FunType					{{ com FunType }}
	| [ T1 ]    ::  :: ArrayType								{{ com ArrayType }}
	| G ["return"] :: :: GammaType 								{{ com GammaType }} 
	| IllDefined ( T )  :: M:: IllDefinedType 					{{ com IllDefinedType }}
	| pending 	:: M:: PendingType								{{ com Pending }} 
	| T1 ~> T2  ::  :: DerivedType 								{{ com DerivedType }}

G {{ tex \Gamma }} :: 'G_' ::= 					{{ com Context }}
	| \{}		::  :: EmptyContext								{{ com EmptyContext }}
	| { G }		::  :: SingletonContext							{{ com SingletonContext }}
	| G u G'	::  :: UnionContext								{{ com UnionContext }}
																	{{ tex [[G]] \cup [[G']] }}
	| id : T 	::  :: ContextItem								{{ com ContextItem }}
	| { id1 : T1 , .. , idk : Tk } 	::  :: ContextItems			{{ com ContextItems }}

C :: 'C_' ::= 					                {{ com Constraint }}
	| \{}		 ::  :: EmptyConstraint							{{ com EmptyConstraint }}
	| C u C'	 ::  :: UnionConstraint							{{ com UnionConstraint }}
																	{{ tex [[C]] \cup [[C']] }}
	| C n C'	 ::  :: IntersectConstraint						{{ com IntersectConstraint }}
																	{{ tex [[C]] \cap [[C']] }}
	| U setIndex = n1 - n2 C :: :: BigUnion 						{{ com BigUnion }}
																	{{ tex \bigcup \limits_{[[setIndex]]=[[n1]]}^[[n2]] [[C]] }}
	| { T1 const T2 } ::  :: ConstLeq 										{{ com ConstLeq }}
	| ( C )		 ::  :: BracketedConstraint  					{{ com BracketedConstraint }}
																	{{ tex [[C]] }}
const :: 'const_' ::=
	| < 		 ::  :: LEqConstraint 							{{ com LEqConstraint }}
																	{{ tex \preceq }} 
	| > 		 ::  :: GEqConstraint 							{{ com GEqConstraint }}
																	{{ tex \succeq }} 
	| <c 		 ::  :: LEqCheckConstraint						{{ com LEqCheckConstraint }}
																	{{ tex \preceq_c }} 
	| >c 		 ::  :: GEqCheckConstraint						{{ com GEqCheckConstraint }}
																	{{ tex \succeq_c }} 
	| <o 		 ::  :: LEqOptConstraint						{{ com LEqOptConstraint }}
																	{{ tex \preceq_o }} 
	| >o 		 ::  :: GEqOptConstraint						{{ com GEqOptConstraint }}
																	{{ tex \succeq_o }} 
	| = 		 ::  :: EqConstraint							{{ com EqConstraint }}
																	{{ tex = }} 


terminals :: 'terminals_' ::=
	| ->        ::  :: rightarrow 									{{ tex \rightarrow }}
	| ~>        ::  :: Rightarrow 									{{ tex \Rightarrow }}
	| G         ::  :: Gamma                						{{ tex \Gamma }}
	| |-        ::  :: Entails              						{{ tex \vdash }}
	| ;         ::  :: semicolon
	| var       ::  :: var
	| \{}		::  :: emptyset             						{{ tex \varnothing }}

sv :: 'sv_' ::= 								{{ com SetVar }}
	| C 		::  :: ConstraintSet						    {{ com ConstraintSet }}
	| X 		::  :: VariableSet							    {{ com VariableSet }}
	| dom( G )	::  :: dom
	| codom( G ) ::  :: codom

fv :: 'fv_' ::= 								{{ com FormulaVar }}
	| G 		::  :: ContextVar							    {{ com ContextVar }}
	| G ( id )  ::  :: ContextMember							{{ com ContextMember }}
	| sv 		::  :: SetFormulaVar							{{ com SetFormulaVar }}
	| T 		::  :: TypeFormulaVar							{{ com TypeFormulaVar }}
	| id 		::  :: IllDefinedFormulaVar								{{ com IllDefinedFormulaVar }}
	| func  	::  :: FuncFormulaVar							{{ com FuncFormulaVar }}
	| e 		::  :: ExpFormulaVar                            {{ com ExpFormulaVar }}

n :: 'n_' ::=
	| 0			::  :: Zero
	| 1			::  :: One
	| 2			::  :: Two
	| 3			::  :: Three
	| setIndex  ::  :: SetIndex

setIndex :: 'ix_' ::=
	| i 		::  :: i
	| k 		::  :: k
	| j 		::  :: j

formula :: formula_ ::=  
	|  judgement                 		::  :: judgement         {{ com judgement }}
	|  not formula               		::  :: not               {{ com not }}
																    	{{ tex \neg [[formula]] }} 
	|  ( formula )               		::  :: brackets          {{ com brackets }}
																    	{{ tex ([[formula]]\!) }}  
	|  [ formula ]               		::  :: bracketsHidden    {{ com bracketsHidden }}
																    	{{ tex [[formula]] }}  
	|  formula1 --- formulak     		::  :: listForm          {{ com listForm }}
																    	{{ tex [[formula1]] \hdots [[formulak]] }}
	|  formula \/ formula’       		::  :: or                {{ com or }}
																    	{{ tex [[formula]] \vee [[formula’]] }}
	|  formula /\ formula’       		::  :: and               {{ com and }}
																    	{{ tex [[formula]] \wedge [[formula’]] }}
	|  formula for formula'      		::  :: condform          {{ com condform }}
																		{{ tex [[formula]] \hspace{1pc}\textit{for}\hspace{6pt} [[formula']] }}
	|  A setIndex formula        		::  :: ForAll				{{ com ForAll }}
																		{{ tex \forall [[setIndex]][[formula]]}}
	|  A setIndex in sv formula  		::  :: ForAllIn			{{ com ForAllIn }}
																		{{ tex \forall [[setIndex]]\in[[sv]][[formula]]}}
	|  fv = fv2                  		::  :: fequal 			{{ com fequal }}
	|  fv != fv2                 		::  :: fnotequal 			{{ com fnotequal }}
																		{{ tex [[fv]] \neq [[fv2]] }}
	|  fv in sv2                 		::  :: Contains			{{ com Contains }}
																	{{ tex [[fv]] \in [[sv2]] }}
	|  fv !in sv2                		::  :: NotContains		{{ com NotContains }}
																	{{ tex [[fv]] \notin [[sv2]] }}
	| T is fresh                 		::  :: Fresh 			{{ com Fresh }} 
	| T1 , .. , Ti are fresh 			::  :: Freshs 			{{ com Freshs }} 



defns
Jop :: '' ::=

	defn
	< m , s > -> < m' , s' > :: ::reduce::''  
	{{ tex \langle [[m]], [[s]] \rangle [[->]] \langle [[m']], [[s']] \rangle }}
	by

		-------------------                        		            ::   Seq1
		<v; m1; ..; mi, s> -> <m1; ..; mi, s>

		<m1, s> -> <m1', s'>
		----------------------------              		            ::   Seq2
		<m1;m2; ..; mi, s> -> <m1'; m2; ..; mi, s'>

		<e, s> -> <e', s'>
		----------------------------                 		        ::   Assign1
		<id Ass e, s> -> <id Ass e', s'>

		---------------------------------            		        ::   Assign
		<id = v, s> -> <v, put(s, [id], [v])>

		----------------------------                 		        ::   AssignNum
		<id numOp= v, s> -> <id = id numOp v, s>

		--------------------------                  		        ::   Deref
		<id, s> -> <get(s, id), s>

		-----------------------------                		        ::   Var1
		<var id, s> -> <eps, s>

		<e, s> -> <e', s'>
		-----------------------------------               		    ::   Var2
		<var id = e, s> -> <var id = e', s>

		----------------------------------------       		        ::   Var3
		<var id = v, s> -> <eps, put(s, [id], [v])>

		----------------------------------------- 			        ::   Var4
		<var vd, vd', s> -> <var vd; var vd', s >

		------------------------------------------------- 			::   FuncDef
		<@def function x(y1,..,yi) {m}, s> -> <eps, put(s, [x], [function (y1,..,yi) {m}])> 

		<e, s> -> <e', s'>
		--------------------------------                            ::   UnOp1
		<preOp e1, s> -> <preOp e1', s'>

		<e, s> -> <e', s'>
		--------------------------------                            ::   UnOp2
		<e1 postOp, s> -> <e1' postOp, s'>

		<e1, s> -> <e1', s'>
		--------------------------------                            ::   BinOp1
		<e1 op e2, s> -> <e1' op e2, s'>

		<e2, s> -> <e2', s'>
		-------------------------------                             ::   BinOp2
		<v op e2, s> -> <v op e2', s'>

		n1 op n2 = n
		-----------------------                                     ::   BinOp3
		<n1 op n2, s> -> <n, s>

		!b1 = b2
		-----------------------                                     ::   BoolNeg
		<!b1, s> -> <b2, s>

		~n1 = n
		-----------------------                                     ::   NumNeg
		<~n1, s> -> <n, s>

		get(s, id) + 1 = v
		-----------------------------                               ::   PostInc
		<id++, s> -> <id, put(s, [id], [v])>

		get(s, id) + 1 = v
		-----------------------------                               ::   PreInc
		<++id, s> -> <id+1, put(s, [id], [v])>

		get(s, id) - 1 = v
		-----------------------------                               ::   PostDec
		<id--, s> -> <id, put(s, [id], [v])>

		get(s, id) - 1 = v
		-----------------------------                               ::   PreDec
		<--id, s> -> <id+1, put(s, [id], [v])>

		<e, s> -> <e', s'>
		--------------------------------------------------------    ::	 If1
		<if (e) {m1} else {m2}, s> -> <if (e') {m1} else {m2}, s'>

		--------------------------------------		                ::	 If2
		<if (true) {m1} else {m2}, s> -> <m1, s>

		--------------------------------------		                ::	 If3
		<if (false) {m1} else {m2}, s> -> <m2, s>
		
		--------------------------------------------------------    ::	 If4
		<if (e) {m1}, s> -> <if (e) {m1} else {}, s'>

		--------------------------------------------------------    ::	 While
		<while (e) {m1}, s> -> <if (e) {m1; while (e) {m1}}, s>

		--------------------------------------------------------    ::	 For
		<for (e1; e2; e3) {m1}, s> -> <e1; if (e2) {m1;e3; while (e2) {m1;e3}}, s>

		<e, s> -> <e', s'>
		---------------------------------------------				::   Obj
		< {l1: v1, .., lj: vj, l: e, l1': e1, .., lj': ej}, s> -> <{l1: v1, .., lj: vj, l: e', l1': e1, .., lj': ej}, s'>

		<e, s> -> <e', s'>
		---------------------------------------------				::   Arr
		< [v1, .., vj, e, e1, .., ek], s> -> <[v1, .., vj, e', e1, .., ek], s'>

		<e, s> -> <e', s'>
		----------------------- 									::   Prop1
		<e.l, s> -> <e'.l, s'>

		----------------------- 									::   Prop2
		< {l1: v1, .., lj: vj, l: v, l1': v1', .., lj': vj'}.l, s> -> <v, s'>

		<e, s> -> <e', s'>
		----------------------- 									::   Call1
		< e(e1,..,ei), s> -> <e'(e1,..,ei), s'>

		<e1, s> -> <e1', s'>
		----------------------- 									::   Call2
		< v(v1,..,vi,e1,e2,..,ej), s> -> <v(v1,..,vi,e1',e2,..,ej), s'>

		<m, put( s, [id, x1,..,xi], [function id(x1,..,xi){m},v1,..,vi])> -> <return v; m', s'>
		----------------------- 									::   Call3
		< function id(x1,..,xi){m}(v1,..,vi), s> -> <v, del(s', [id,x1,..,xi])>

		<m, put( s, [x1,..,xi], [v1,..,vi])> -> <return v; m', s'>
		----------------------- 									::   Call4
		<function (x1,..,xi){m}(v1,..,vi), s> -> <v, del(s', [x1,..,xi])>

		<v.l,s> -> <function id (x1,..,xi){m}, s'>
		--------------------------------------------------------- 	:: 	PropCall
		<v.l(e1,..,ei),s> -> <function id (this,x1,..,xi){m}(v,e1,..,ei), s'>

	% Note: Only expressions have a type - the more general statements do not
	defn
	G |- e : T | C G' :: ::expType::''
	 {{ tex [[G]] [[|-]] [[e]] : [[T]]\hspace{5pt}| _{ [[C]] } \hspace{5pt} [[G']] }}
	 by




		% Typing rules for values

		-------------------------                           		:: V_Num
		G |- n : number |\{} G

		--------------------------                          		:: V_Bool
		G |- b : boolean |\{} G

		---------------------------                         		:: V_String
		G |- str : string |\{} G

		------------------------------------                		:: V_Undefined
		G |- undefined : undefined |\{} G

		--------------------------                          		:: V_Null
		G |- null : null |\{} G





		% Object types simply depend on their expressions

		T1, .., Tk are fresh
		G |- e1 : T1' | C1 G1   ---   Gk-1 |- ek : Tk' | Ck Gk 
		C = (U i=1-k Ci) u (U i=1-k {Ti = Ti'})
		---------------------------------------------------------   :: V_Obj
		G |- {l1: e1, .., lk: ek} : {l1: T1, .., lk: Tk} |C Gk





		% Array types simply depend on their expressions too (but all constrained to one)

		T is fresh
		G |- e1 : T1 | C1 G1   ---   Gk-1 |- ek : Tk | Ck Gk 
		C = (U i=1-k Ci) u (U i=1-k {T >c Ti'})
		---------------------------------------------------------   :: V_Arr
		G |- [e1, .., ek] : [T] |C Gk





		% Function types:

		% ill-defined & pending means there were no returns anywhere
		
		T, T0, T1, .., Ti are fresh
		G u {this: T0, x1:T1, .., xi:Ti} |- m1; ..; mj |C G'
		G'["return"] = pending
		----------------------------------------------------------------------- :: V_Fun1
		G |- function (x1, .., xi) { m1; ..; mj } : (T0, T1, .., Ti -> T) |C u {T = undefined} G

		% if the return is not ill-defined, we use its type for the function
		
		T, T0, T1, .., Ti are fresh
		G u {this: T0, x1:T1, .., xi:Ti} |- m1; ..; mj |C G'
		G'["return"] = Tk
		Tk != IllDefined(Tk')
		----------------------------------------------------------------------- :: V_Fun2
		G |- function (x1, .., xi) { m1; ..; mj } : (T0, T1, .., Ti -> T) |C u {T = Tk} G

		% NB the case IllDefined(T) is not covered, as this is illegal

		% 3 and 4 just add 'id' to the inner type environment (otherwise like 1 and 2)

		T, T0, T1, .., Ti are fresh
		G u {this: T0, x1:T1, .., xi:Ti, id:(T0, T1, .., Ti -> T)} |- m1; ..; mj |C G'
		G'["return"] = IllDefined(pending)
		----------------------------------------------------------------------- :: V_Fun3
		G |- function id(x1, .., xi) { m1; ..; mj } : (T0, T1, .., Ti -> T) |C u {T = undefined} G

		T, T0, T1, .., Ti are fresh
		G u {this: T0, x1:T1, .., xi:Ti, id:(T0, T1, .., Ti -> T)} |- m1; ..; mj |C G'
		G'["return"] = Tk
		Tk != IllDefined(Tk')
		----------------------------------------------------------------------- :: V_Fun4
		G |- function id(x1, .., xi) { m1; ..; mj } : (T0, T1, .., Ti -> T) |C u {T = Tk} G




		
		% Variable retrieval

		% can't read an ill-defined variable (one which may not have been initialised)
		G(id) = T
		T != IllDefined(T')
		---------------------		                                :: IdType
		G |- id : T |\{} G

		T is fresh
		G |- e : T1 |C G1
		---------------------------------------------------------   :: PropType
		G |- e.l : T |C u {{l:T} > T1} G1
	
		% NB in JSTyper we don't allow string-keyed array accesses
		T is fresh
		G  |- e1 : T1 |C1 G1
		G1 |- e  : T2 |C2 G2
		---------------------------------------------------------   :: ArrayType
		G |- e[e1] : T |(C1 u C2) u ({[T] > T2} u {T1 = number}) G2
	




		% Function Calls

		% I'm saying 'this' is undefined if unspecified (in practice 'this' is global object e.g. window)

		T0,T1,..,Ti,Tk,Tk' are fresh
		G  |- e  : T   |C0 G0
		G0 |- e1 : T1' |C1 G1   ---   Gi-1 |- ei : Ti' |Ci Gi
		C' = ({T0 = undefined} u (U j=1-i {Tj >c Tj'})) u ({Tk <c Tk'} u {T=(T0, T1, .., Ti -> Tk)})
		-------------------------------------------------- 			:: CallType
		G |- e(e1,..,ei) : Tk' |(U j=0-i Cj) u C' Gi

		T0,T1,..,Ti,Tk,Tk' are fresh
		G  |- e.l : T   |C0 G0
		G  |- e   : T0' |C' G'
		G0 |- e1  : T1' |C1 G1   ---   Gi-1 |- ei : Ti' |Ci Gi
		C' = ({T0 >c T0'} u (U j=1-i {Tj >c Tj'})) u ({Tk <c Tk'} u {T=(T0, T1, .., Ti -> Tk)})
		-------------------------------------------------- 			:: PropCallType
		G |- e.l(e1,..,ei) : Tk' |(U j=0-i Cj) u C' Gi





		% Assignment operations

		G(id) = T
		G  |- e' : T1 |C1 G1
		------------------------------------------------------	 	:: AssignType 
		G  |- id = e' : T1 |C1 u { T >c T1 } G1

		T is fresh
		id !in dom(G)
		G  |- e' : T1 |C1 G1
		------------------------------------------------------	 	:: AssignTypeUndef
		G  |- id = e' : T1 |C1 u { T >c T1 } G2 u {id: T}

		% dots make list comprehensions hard to express in OTT
		
		T is fresh
		G  |- e' : T' |C' G'
		G' |- id : T0 |C0 G''
		G' |- id.l1 : T1 |C1 G''
		G' |- id.l1.lk : Tk |Ck G''
		G1 = Gk u {id: { l1 :{ lk: {l:T}~>Tk }~>T1 }~>T0 }
		C = { {l:T3} >o Tk } u {T >c T'}
		------------------------------------------------------	 	:: PropAssignType
		G  |- id.l1.lk.l = e' : T' |(U j=0-i Cj) u (C' u C) G1

		G  |- e1 : T1 |C1 G1
		G1 |- e2 : T2 |C2 G2
		G2 |- e3 : T3 |C3 G3
		------------------------------------------------------	 	:: ArrayAssignType 
		G  |- e1[e2] = e3 : T1 |((C1 u C2) u C3) u ({T2=number} u {[T1] >c T3}) G3

		G1 |- id : T1 |C1 G1
		G  |- e' : T2 |C2 G2
		------------------------------------------------------	 	:: NumAssignType
		G  |- id numOp= e' : T1 |(C1 u C2) u ({ T2 = T1 } u {T1 = number}) G2

		G  |- e  : T1 |C1 G1
		G1 |- e' : T2 |C2 G2
		------------------------------------------------------	 	:: PropNumAssignType
		G  |- e.l numOp= e' : T2 |(C1 u C2) u ({ {l:number} > T1 } u {T2 = number}) G2

		G  |- e1 : T1 |C1 G1
		G1 |- e2 : T2 |C2 G2
		G2 |- e3 : T3 |C3 G3
		------------------------------------------------------	 	:: ArrayNumAssignType 
		G  |- e1[e2] numOp= e3 : T1 |((C1 u C2) u C3) u ({T2=T1} u ({[T1] = [number]} u {T3=number})) G3





		% Mathematical Binary Operations

		G  |- e1 : T1 |C1 G1
		G1 |- e2 : T2 |C2 G2
		------------------------------------------------------------  :: NumOpType
		G |- e1 numOp e2 : number |(C1 u C2) u ({T1 = number} u {T2 = number}) G2

		% Boolean Binary operations

		G  |- e1 : T1 |C1 G1
		G1 |- e2 : T2 |C2 G2
		------------------------------------------------------------  :: BoolOpType
		G |- e1 boolOp e2 : boolean | (C1 u C2) u ({T1 = boolean} u {T2 = boolean}) G2

		% TODO? Object comparison always returns false, and I think == should be disallowed, at least for objects
		% Equality Operations

		G  |- e1 : T1 |C1 G1
		G1 |- e2 : T2 |C2 G2
		-------------------------------------------------------		  :: CmpOpType
		G |- e1 cmpOp e2 : boolean |(C1 u C2) u {T1 = T2} G2

		G  |- e1 : T1 |C1 G1
		G1 |- e2 : T2 |C2 G2
		-------------------------------------------------------		  :: NumCmpOpType
		G  |- e1 numcmpOp e2 : boolean |(C1 u C2) u ({T2 = number} u {T1 = number}) G2





		% Unary Operation

		G |- e : T1 |C G'
		------------------------------------------- 	:: NegType
		G |- !e : boolean |C u {T1 = boolean} G'

		G |- e : T1 |C G'
		------------------------------------------- 	:: PreNumType
		G |- preNum e : number |C u {T1 = number} G'

		% all post-ops are for numbers

		G |- e : T1 |C G'
		------------------------------------------- 	:: PostOpType
		G |- e postOp : number |C u {T1 = number} G'


	defn
	G |- m | C G' :: :: typable::'' 
	 {{ tex [[G]] [[|-]] [[m]] \hspace{5pt}| _{ [[C]] } \hspace{5pt} [[G']]}}
	 by
		% We say that a statement m is typable if all expressions contained within it are well typed by the definition above.

		G |- e : T |C G'
		-------------------                                		    :: ExpTypable
		G |- e |C G'

		G |- function id(x1, .., xi) { m1; ..; mj } : T |C G'
		----------------------------------------------------------------------- :: V_FunDef
		G |- @def function id(x1, .., xi) { m1; ..; mj } |C G' u {id: T}

		G |- return undefined |C G'
		--------------------------- 								:: RetTypable1
		G |- return |C G'

		G |- e : T |C G'
		G'["return"] = pending
		--------------------------------- 							:: RetTypable2
		G |- return e |C G' u {return: T}

		G |- e : T |C G'
		G'["return"] = IllDefined(T')
		------------------------------------------ 					:: RetTypable3
		G |- return e |C u {T=T'} G' u {return: T}

		G |- e : T |C G'
		G'["return"] = T'
		------------------------------------------					:: RetTypable4
		G |- return e |C u {T=T'} G'


		G |- m1 |C1 G1 --- Gi-1 |- mi |Ci Gi
		---------------------------------                		    :: SeqTypable
		G |- m1; ...; mi |U i=0-k Ci Gi

		G |- e : T1 |C1 G1
		G1 |- m1 |C2 G2
		G1 |- m2 |C3 G3
		---------------------------------                		    :: IfTypable1
		G |- if (e) {m1} else {m2} |(C1 u (C2 u C3)) u {T1 = boolean} G1

		G |- e : T1 |C1 G1
		G1 |- m1 |C2 G2
		---------------------------------                		    :: IfTypable2
		G |- if (e) {m1} |(C1 u C2) u {T1 = boolean} G1

		T is fresh
		---------------------------------                		    :: DecTypable
		G |- var id |\{} G u {id : T}

		T' is fresh
		G |- e : T |C G'
		---------------------------------                		    :: DefTypable
		G |- var id = e |C u {T' <c T} G' u {id : T'}

		G |- var vd1 |C1 G1 --- Gk-1 |- var vdk |Ck Gk
		---------------------------------------            		    :: MultiDecTypable
		G |- var vd1,...,vdk |(U i=i-k Ck) G2
