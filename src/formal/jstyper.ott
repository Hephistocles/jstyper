% v0.1.2
% Version numbering: (project_goals_met?1:0).(added syntax).(refined spec)
grammar

% syntax

id :: 'id_' ::=

v :: 'v_' ::=                   {{ com Values }}
	| b         ::  :: Boolean            {{ com Boolean }}
	| n         ::  :: Number             {{ com Number }}
	| str       ::  :: String             {{ com String }}
	| undefined ::  :: Undefined          {{ com Undefined }}
	| null      ::  :: null               {{ com null }}
	| get( s , id ) :: M:: GetStore       {{ com GetStore }}

s :: 's_' ::=                   {{ com Store }}
	|  put( s , id , v ) :: M:: PutStore  {{ com PutStore }}

vd :: 'vd_' ::=                 {{ com VariableDeclaration }}
	| id        ::  :: Declaration        {{ com Declaration }}
	| id = e    ::  :: Definition         {{ com Definition }}
	| vd , vd'  ::  :: Multiple           {{ com Multiple }}

e :: 'e_' ::=                   {{ com Expression }}
	| v         ::  :: Value              {{ com Value }}
	| id        ::  :: Deref              {{ com Deref }}
	| id = e    ::  :: Ref                {{ com Ref }}

m :: 'm_' ::=                   {{ com Statement }}
	| e         ::  :: Expression         {{ com Expression }}
	| eps  ::  :: Skip {{ tex \epsilon }} {{ com Skip }}
	| m ; m'    ::  :: Seq                {{ com Seq }}
	| var vd    ::  :: VarDeclaration     {{ com VarDeclaration }}

% Typing definitions
% TODO: We will need to do something clever here to allow for object types

Tv :: 'Tval_' ::=				{{ com Value Type }}
	| number    ::  :: Number             {{ com Number }}
	| boolean   ::  :: Boolean            {{ com Boolean }}
	| string    ::  :: String             {{ com String }}
	| undefined ::  :: undefined          {{ com undefined }}
	| null      ::  :: null               {{ com null }}

T :: 'T_' ::=                   {{ com Expression Type }}
	| Tv 		::  :: ValueType			{{ com ValueType }}
	| ref< Tv > ::  :: RefType				{{ com Location Type }}
								{{ tex ref \langle [[Tv]] \rangle}}
	

% Things Ott wants

X :: 'X_' ::= 
	| S 		::  :: Set

C :: 'C_' ::= {{ com Constraints}}
	| S		::  :: Set

S :: 'S_' ::= 					{{ com Set }}
	| {}		::  :: EmptySet 			{{ com EmptySet }}
	| { T }		::  :: Singleton			{{ com Singleton }}
	| X u X'	::  :: Union				{{ com Union }}
											{{ tex [[X]] \cup [[X']] }}
	| X n X'	::  :: Intersect			{{ com Intersect }}
											{{ tex [[X]] \cap [[X']] }}


terminals :: 'terminals_' ::=
	| ->        ::  :: rightarrow {{ tex \rightarrow }}
	| G         ::  :: Gamma {{ tex \Gamma }}
	| |-        ::  :: Entails {{ tex \vdash }}
	| ;         ::  :: semicolon
	| var       ::  :: var
	| {}		::  :: emptyset {{ tex \varnothing }}


defns
Jop :: '' ::=

defn
< m , s > -> < m' , s' > :: ::reduce::''  by

	----------------------------                      :: seq1
	<v; e, s> -> <e, s>

	<e1, s> -> <e1', s'>
	--------------------------------------            :: seq2
	<e1; e2, s> -> <e1'; e2, s'>

	<e, s> -> <e', s'>
	-----------------------------------               :: assign1
	<id = e, s> -> <id = e', s'>

	----------------------------------------          :: assign2
	<id = v, s> -> <v, put(s, id, v)>

	----------------------------------                :: deref
	<id, s> -> <get(s, id), s>

	-------------------------------------             :: var1
	<var id = e, s> -> <id = e, s>

	------------------------------------              :: var2
	<var id, s> -> <undefined, s>

	------------------------------------------------- :: var3
	<var vd, vd', s> -> <var vd; var vd', s >

defn
G ( id ) = T :: M::expType2::''  by
	

defn
G |- e : T | X C :: ::expType::''
 {{ tex [[G]] [[|-]] [[e]] : [[T]]\hspace{5pt}| _{ [[X]] } \hspace{3pt}[[C]] }}
 by
	% Note: Only expressions have a type - the more general statements do not

	% Trivial typing rules for values

	---------------                                   :: v_num
	G |- n : number | {} {}

	---------------                                   :: v_bool
	G |- b : boolean | {} {}

	---------------                                   :: v_string
	G |- str : string | {} {}

	---------------                                   :: v_undefined
	G |- undefined : undefined | {} {}

	---------------                                   :: v_null
	G |- null : null | {} {}
%
	% Mildly more interesting - assign / deref rules.
%	G(id) = ref<Tv>
%	------------------                                :: DerefType
%	G |- id : T |{} {}
%
%	G(id) = ref<Tv>
%	-----------------                                 :: RefType
%	G |- id : ref<Tv> |{} {}

	G(id) = T
	----------											:: IdType
	G |- id : T |{ T } {}

	% Problem of typing id: it needs to be typed as either a T or a ref<T>. In either case, what should G(id) be?
	% My solution: id legitimately needs to be able to be typed in either case, so we need both Ref and DerefType rules. G internally just stores id as having type ref<Tv>


	G |- id : T1 |X1 C1 
	G |- e : T2 |X2 C2
	! X1 n X2 = X1 n X(T2) = X2 n X(T1) = {}
	! X' = X1 u X2
	! C' = C1 u C2 u {T1 = ref<T2>}
	------------------                                	:: AssignType
	G |- id = e : T2 |X' C'


defn
G |- m | X C :: :: typable::'' 
 {{ tex [[G]] [[|-]] [[m]] \hspace{5pt}| _{ [[X]] } \hspace{3pt}[[C]] }}
 by
	% We say that a statement m is typable if all expressions contained within it are well typed by the definition above.

	% NB We're going to need to do something to model scope within G

	--------  	                                        :: SkipTypable
	G |- eps |{} {}

	----------- 	                                    :: DecTypable
	G |- var id |{} {}

	G |- e : T |X C
	----------    	                                    :: ExpTypable
	G |- e |X C

	G |- m1 |X1 C1
	G |- m2 |X2 C2
	!X1 n X2 = {}
	!C' = C1 u C2
	!X' = X1 u X2
	-----------  	                                    :: SeqTypable
	G |- m1 ; m2 |X' C'

	G |- var id | X1 C
	G |- id = e : T |X2 C
	!X1 n X2 = {}
	!C' = C1 u C2
	!X' = X1 u X2
	---------------- 	                                :: DefTypable
	G |- var id = e | X' C'

	G |- var vd |X1 C1
	G |- var vd' |X1 C2
	!X1 n X2 = {}
	!C' = C1 u C2
	!X' = X1 u X2
	----------------- 	                                :: MultiDecTypable
	G |- var vd, vd' | X' C'